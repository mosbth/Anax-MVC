# Rapporter

## Kmom10

Länk till webbplatsen [Gamla Hus: http://www.student.bth.se/~frnf15/gamlahus/webroot/](http://www.student.bth.se/~frnf15/gamlahus/webroot/)

Gamla Hus på [github: https://github.com/fnlive/gamlahus](https://github.com/fnlive/gamlahus)

Länk till min [Me-sida: http://localhost/BTH-KP201/dbwebb-kurser/phpmvc/me/kmom10/Anax-MVC/webroot/index.php/redovisning](http://localhost/BTH-KP201/dbwebb-kurser/phpmvc/me/kmom10/Anax-MVC/webroot/index.php/redovisning)

Utifrån kravtexten försökte jag först sätta ihop en "usecase" beskrivning av webbplatsen. Jag fick ihop en drygt 10 stycken use case som säger samma sak som kravtexten men på ett som kändes mer kopplat till vad slutanvändaren ser och även underlättar att implementera hela eller delar av ett usecase. Parallellt med detta drog jag upp en databasmodell med en entity-relationship modell. Centralpunkten tyckte jag var en "fråga" som allt annat utgår ifrån. En användare kan fråga en fråga med taggar som någon kan svara på. Fråga och svar kan kommenteras. Var och en av dessa saker fick bli en egen tabell i databasen. Jag hittade en många-till-många relation pga en fråga kan ha flera taggar och en tagg kan vara kopplad till frågor. För detta skapade jag en mappningstabell mellan fråga till tag och vice versa.

När jag skulle börja skapa databasen var jag inne på att knyta ihop tabellerna, framförallt mappningstabell för tags-fråga, med foreign keys. Samtidigt fanns CDatabaseModel sedan tidigare som var smidig att använda men som inte hade stöd för att knyta ihop flera tabeller. Jag prövade därför med att göra alla tabeller som varsin modell baserad på CDatabaseModel. Detta har fungerat bra, men en framtida förbättring är att knyta ihop tabeller mha foreign keys och skapa ett lämpligt set av vyer för att få fram rätt data med en sökning. Som det är nu behöver jag ofta göra flera sökningar i de olika modellerna för att få fram rätt slutdata. T.ex. behövs tre databasslagningar för att komma från tag-name till tag-id till q-id för en fråga. Med en framtida optimering går det nog att få ner till en slagning med en sql-vy som gör join på flera tabeller.

Jag valde att använda [SQLite](https://www.sqlite.org/) som databas då den fungerat fint tidigare under kursen.

Webbplatsen skyddas av inloggning genom kontroll av att användaren är inloggad i controllers för att fråga fråga, svara fråga, kommentera, samt lägga till eller uppdatera användare. Användaren loggas in genom att session-variabeln 'user' sätts till användarens 'acronym'. Tilldelningen görs via tjänsten session->set(). Vid utloggning tas session variabeln bort. Kontroll om användaren är inloggad görs också vid generering av url till besvara/kommentera/fråga-länkarna där dessa pekar till login-sidan om användaren inte är inloggad.

Första sidans tre vyer skapas mha dispatch till questions-, tags-, resp. users-controller. Dessa vyer tog jag fram sist i projektet. Här fick jag ta fram nya sql-querys i modellerna för questions, answers, och comments som räknade antal rader för en viss användare. [sqlite-manager](https://github.com/lazierthanthou/sqlite-manager) var ett bra verktyg både för att pröva ut queries samt för att titta på och modifiera innehållet i databasen. (Även om jag tycker [MySQL Workbench](https://www.mysql.com/products/workbench/) är ännu smidigare att arbeta med.) Användarnas aktivitet räknas samman genom att addera deras respektive antal frågor, svar och kommentarer. Jag listar de tre mest aktiva användarna genom att sortera array'n med användare-aktivitet (arsort()) med mest aktiva användare först och plockar ut de tre mest aktiva med array_slice(). För att få fram mest populära taggar börjar jag i korsreferenstabellen 'questions2tags' för att räkna fram mest populära taggar. Med dessa tag-id tar jag fram tag-data ur tag-modellen och kan lista de tre mest populära. För att hitta de senaste frågorna använde jag ett query som sorterade frågorna i bakvänd kronologisk ordning samt satte "LIMIT 3" för att få ut de 3 senaste frågorna.

Vid listning av de frågor en viss användare har besvarat, börjar jag med att söka fram alla svar för användaren. Respektive innehåller referens till besarad fråga, vilket gör att jag då kan söka fram alla frågor. Då samma användare kan ha besvarat en fråga flera gånger behöver alla duplikat av frågor sorteras bort vilket kan göras med array-operationen 'array_unique()'. Listning av frågor som en användare har ställt är mer rättframt.

Listning av frågor enligt ovan stycke samt frågor med en viss tag hanteras av samma dispatcher med route *questions/list/[answers|questions|tags]/identity*. Motivet till att ha samma dispatcher är att det mesta av hanteringen är samma, dvs. visa frågorna tillsammans med frågans taggar och användare. Det som skiljer är enbart hur frågorna söks fram, vilket hanteras i en switch-sats som växlar på default: alla frågor; answers: alla frågor svarade av en viss användare; questions: alla frågor från en viss användare; tags: alla frågor med en viss tag.

Halvvägs in i projektet kände jag att jag tappade översikt över vilka routes som fanns och i vilka controllers de var eller borde vara implementerade i. Jag tog därför fram en lista över alla routes och kunde då enklare mappa in behov av nya routes samt uppdatera eller slänga redan skapade routes. Med mer tid hade jag velat skapa något bättre struktur på route-hierarkier samt använt snygga url-namn överallt. Nu är det en mix av "snygga" url's, t.ex. ".../users/profile/fnlive", ihop med url's som är mindre snygga med numeriska id'n, t.ex. "questions/single/1". Speciell hänsyn behöver också tas till tecken som inte fungerar i en url, så någon form av konvertering behövs från t.ex. titlar till url-del.

Konvertering till html från markdown format görs i "view-template-filerna" för frågor, svar och kommentarer. Alternativt hade konverteringen kunnat göras i controllers vid anrop till 'views->add()', men är sämre då samma vy kan användas från flera punkter i olika controllers, samt att controllers inte bör ha kunskap om lagrat format. Ett bättre ställe hade kunnat vara att göra konverteringen i modellerna (CQuestions,CAnswers och CommentsInDb) när data hämtats ut ur databasen.

Under meny-valet [Byggare](users/list) listas alla registrerade användare. Överst på denna sida visas ett inloggnings-formulär. Om en användare har loggat in så visas dennas profil tillsammans med olika val t.ex. för att redigera användar-profil och lägga till nya användare. Här finns också länkar för att visa användarens frågor denne har ställt som frågor som denne har besvarat. Klickar man på en annan användare i listan få får man upp länkar till dennes frågor och besvarade frågor. sidan hanteras av en dispatcher *users/list* som först anropar vy baserat på om en användare är inloggad eller ej och sist anropar vy som listar alla användare.

Jag implementerade *märkning av accepterat svar*. Grundhanteringen var relativt enkel. Lägga till en länk under varje svar som länkar till en dispatcher som uppdaterar databasen. Svaret markeras som accepterat och frågan markeras också att den fått ett accepterat svar. Det senare var ett lätt sätt för att undvika att användaren kan markera flera svar som accepterade. Ett något snyggare sätt kanske hade varit en query som sökte igenom svars-tabellen på både question-id och accepterat svar. Utöver denna grunthantering behövs en hel del kontroller för både visning av länkar samt skydd i controllers, t.ex. är det bara den som ställt frågan som kan acceptera eller att frågan inte redan har ett accepterat svar.  

Överlag har projektet gått bra att genomföra. Det har varit mycket att kod att implementera och det har tagit mer tid än jag hade trott från början. Jag har inte råkat ut får några större problem men ganska många mindre problem som först känts svåra att kommma vidare med men ändå gått att felsöka och lösa. Funktionen dump() har varit en väldigt bra vän tillsammans med sqlite-manager. Ett fåtal problem har jag inte lyckats lösa utan gått runt på andra sätt. Svårast är att få en bra översikt och struktur över alla routes, dispatchers och views. Lite mer tid och refaktorering så hade jag nog fått städat undan oanvänd kod samt lite mer logisk struktur på routes. Jag känner inte heller att jag behärskar ramverket helt ännu och drar full nytta av det. Med mer tid hade jag också velat jobba mer med design och layout av sidorna. Överlag tycker jag att projektet har varit både roligt, lagom utmanande och lärorikt.

phpmvc har varit en väldigt bra kurs som byggt vidare på oophp och htmlphp. Bra få inblick i arkitektur och designmönster för att skapa bättre struktur. Därmed har kursen varit betydligt tuffare och mer svårsmält än oophp och htmlphp. Det kändes då lite skönt med två lättare moment med less, grid-system etc och enhetstest med travis och Scrutinizer. Jag försökte studera de läsanvisningar som fanns till ramverket phalcon, men tyckte inte jag hade speciellt stor nytta av dem. Jag tycker det är svårt att lära genom att läsa text och kodexempel. Detta är säkert en vanesak och något jag kan bli bättre på. Jag tycker det är enklare att lära sig genom att läsa och samtidigt pröva ut tekniken i riktiga exempel. Överlag är jag väldigt nöjd med kursen och känner att jag fått en väldigt mycket bättre grund i php, samtidigt som jag fått lite inblick i less, grid-system, automatiska tester och komponent-hantering med composer. Bra kurs som gått både på bredden och på djupet. Jag ger kursen betyget 9.

## Kmom06

Jag är bekant med enhetstester och continuous integration sedan tidigare då vi använder det på min arbetsplats. Däremot har jag inte själv praktiskt arbetat med detta. Väldigt rolig och nyttig övning.

Jag valde att använda "calendar"-appen som jag gjorde i extrauppgiften för kmom01. Anledningen var att det varnades i uppgiftstexten att det kunde bli ganska krångligt göra enhetstester om modulen var beroende av andra moduler, databas och MVC-Anax. Min Contactform-modul är beroende av allt detta samt även en ny tjänst i ramverket, CDatabaseModel, som jag lade till i kmom04. Så då hade jag även behövt publicera mitt eget Anax-MVC på packagist. Det kändes som att det blev för många saker som kunde krångla.

Jag valde att ha kvar calendar under app samtidigt som jag kopierade in den under vendor mha packagist då de har olika namespace. Med detta fick jag fick lite mer övning i [github](https://github.com/fnlive/calendar) och [packagist](https://packagist.org/packages/fnlive/calendar) genom publiceringen där.

Det gick smidigt att börja göra enhetstester. CCalendar har en halvstor konstruktor, ett antal små get-metoder samt en större metod för att beräkna och returnera hur en kalender-månad ser ut. Jag började med att göra test-funktioner för de små metoderna och sedan den större. För den större metoden, datesInMonth(), testade jag bara stickprov på returnerat data. Jag valde att validera en vecka i mitten på en månad samt två datum som ligger i månaden före resp. månaden efter. Jag testar att datum är som förväntat samt att strängar som används för css-klasser sätts rätt, t.ex. helgdag, datum utanför månad. Klassens metoder innehåller ingen komplicerad "branch-logik" så det var enkelt att få 100% kodtäckningsgrad. Det jag inte har full täckning på är datarymden på in/ut-parameter där jag skulle kunna testa alla datum i månaden samt att testa för många fler månader, februari under skottår och icke skottår etc.

[Travis](https://travis-ci.org/fnlive/calendar) var ganska rättframt att få fungera. Dock verkade Travis php-installation inte ha stöd för "Swedish" locale. Mina enhetstester förväntade sig svensk stavning på månader. Så jag plockade bort setlocale() och körde engelska istället i valideringarna. Då fick jag igenom körningar med php 5.4 och 5.5. Webb-servern på BTH stödde inte heller "Swedish" locale och jag gav mig inte på att gräva i det. HHVM gav dock fortfarande fel. php-funktionen cal_days_in_month() var okänd för HHVM. Jag valde då att plocka bort HHVM som test-mål. Jag tror inte jag vill kunna köra HHVM (just nu). Däremot skulle jag vilja pröva att testa med php 7.0. Men nu fick jag i varje fall ett grönt märke:

[![Build Status](https://travis-ci.org/fnlive/calendar.svg?branch=master)](https://travis-ci.org/fnlive/calendar)&nbsp; (Jag testar med php 7.0 också. Jo, det funkade. :-)

Det verkar såklart finnas lösningar på HHVM/cal_days_in_month() ([1](https://gist.github.com/rawcreative/c67f47b8d6508e6017c5), [2](https://github.com/facebook/hhvm/issues/4572)), men jag gick inte vidare med detta.

[Scrutinizer](https://scrutinizer-ci.com/g/fnlive/calendar/) gick också väldigt enkelt att få igång. Jag var dock lite skeptisk till vad den skulle kunna hitta i min kod. Visade sig att den hittade två buggar eller kanske dålig/osäker kod. Jag hade glömt deklarera en medlems-variabel som jag tilldelade ett värde i konstruktorn och sedan använde variabeln i en klass-metod. php-tolken verkar ha kunnat hantera detta ändå, men fel var det ju. Andra felet var en arry-variabel som inte självklart tilldelades ett värde innan det returnerades i funktionen datesInMonth(). Utöver detta var det en del bortkommenterad kod som jag kunde rensa bort. Efter detta kände jag mig väldigt nöjd och kunde lägga till ytterligare två märken:

[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/fnlive/calendar/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/fnlive/calendar/?branch=master) [![Code Coverage](https://scrutinizer-ci.com/g/fnlive/calendar/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/fnlive/calendar/?branch=master) &nbsp;

Det här var bra verktyg som jag vill använda och lära mig mer om. Utöver att de hjälper till att få ett automatiserat skyddsnät när jag ändrar i något som fungerat tidigare, så hjälper det mig lära mig att förstå php och kodning bättre. Scrutinizer hjälper att fånga både allvarligare buggar som slunkit igenom enhetstest samt ger feedback på min kod för att göra den enklare och mer lättläst. Det verkar finnas en hel del mer som Scrutinizer kan hjälpa till med, t.ex. fånga "[XSS vulnerabilities](https://scrutinizer-ci.com/blog/php-security-analysis-finds-xss-vulnerability-in-popular-wordpress-plugins)".

Vad gäller enhetstester så tror jag svårigheten som utvecklare ligger i att skriva bra enhetstester som verkligen testar funktionerna. Det är ofta lätt att skriva tester och få hög **kodtäckningsgrad**. För att även få tillräcklig **testtäckningsgrad** behöver man även ha koll på hur man ska variera indata till funktioner som testas. Normalfall, ytterlighetsfall, felfall, etc.

Jag valde att inte göra extrauppgiften.

## Kmom05

Jag valde att göra en "Contact form"-modul med inspiration från två WordPress plugins [Contact Form 7](https://wordpress.org/plugins/contact-form-7/) och [Flamingo](https://wordpress.org/plugins/flamingo/). Med CF7 kan man skapa flexibla formulär och få formulärdatat skickat till en email-mottagare. Flamingo lägger till möjligheten att spara meddelanden från CF7 till lokal databas utöver att mail skickas iväg, samt lagrar även kontaktuppgifter lokalt i databas för alla som via CF7 submittar namn, email etc. Normalt brukar "Contact form" plugins enbart skicka vidare meddelandet via mail. En risk med detta är att mailet kan försvinna i spam-filter hos mottagaren alternativt att webbservern får problem att skicka iväg mailet. Meddelandet går då förlorat. En lösning är då att spara meddelandet lokalt på servern i en databas. Min modul är en väldigt förenklad variant av detta. Användaren kan lägga till en vy mha dispatcher för att visa kontaktformuläret  på valfri sida. För att visa och adminstrera meddelandena behöver användaren lägga till en annan vy mha dispatcher på en lämplig route. Denna route bör enbart göras åtkomlig för webb-adminstratören.

"Contact Form"-modulen är baserad på och lik Comment-modulen jag tog fram i Kmom04. Funktionen är dock annorlunda och fyller ett specifikt behov. Jag började med att bygga upp modulen i ett sub-repo under Anax-MVC/vendor. Efter lite felsökning, förmodligen problem med autoloader, så flyttade jag ut sub-repot utanför Anax-MVC. Istället testade jag ut funktionalitet med modulen under Anax-MVC/src.

När det väl funkade under /src, flyttade jag in filerna till ett "Contactform"-repo utanför Anax-MVC, i rätt mapp-struktur, ändrade namespace, och skapade en autoloader-fil. Sedan var det "bara"  att koppla ihop så att repot pushades till github,  contactform-modulen hämtades från git till packagist, och sist från packagist ner till vendor-mappeni Anax-MVC. Efter några småjusteringar i koden så funkade det igen. Detta gick över förväntan smidigt. Efter att jag fick ner contactform-modulen till vendor-mappen kunde jag återigen jobba i denna mappen som ett sub-repo för contactform.

Standardinstallation av Anax MVC har jag valt att definiera såsom min version av [Anax-MVC v.04 kmom04](https://github.com/fnlive/Anax-MVC/releases/tag/v0.4), dvs Anax-MVC från föregående moment. Utöver de beroenden som jag listat i installatins-anvisning på github/packagist så behövs även Anax-MVC/src/MVC/CDatabaseModel.php, som finns just i denna version av Anax-MVC.

Jag prövade installation från scratch genom att följa min [instruktion](https://github.com/fnlive/contactform#installation), ladda ner [Anax-MVC v.04 kmom04](https://github.com/fnlive/Anax-MVC/releases/tag/v0.4), uppdatera composer-fil, köra composer-update, kopiera template-filer, testa test-fil i webbläsaren. Det funkade såklart inte direkt utan jag fick göra små modifieringar både i instruktion och  testContactform.php några gånger för att få allt på plats. Blir lätt omständligt att uppdatera hela vägen med git add/commit/push, update i packagist, och sedan composer update, för varje lite ändring man vill testa. Det skall gå att få till automatisk uppdatering av Packagist när github uppdateras, men jag har inte lyckats aktivera detta.  

Kopieringen av template-filer känns lite onödig. Det kanske skulle gå att peka ut dessa på dess ursprungliga ställe.

Jag har även integrerat contactform-modulen i denna Anax-installation. Exempel på kontaktformuläret kan man hitta under meny-valet [Tärning](dice). Adminstration av meddelanden kan man göra under meny-valet [Admin/Meddelanden](admincontacts). Insikt i struktur och funktion i Anax-MVC har ytterligare fördjupats med denna uppgift. Jag navigerar runt i koden lite mer självsäkert nu.

Jag gjorde ingen extrauppgift.

## Kmom04

Generellt var detta en omfattande och tung uppgift. Jag slogs med många relativt enkla fel som tog tid att hitta. T.ex. funkade redirectTo() fint i UsersController men inte i CommentController. Missat att lägga med "use 'namespace'". Fick även läsa på igen om sql-syntax och installera [SQLite Manager](https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/) för att pröva ut queries i en kontrollerad miljö. Etc. Har definitivt utökat debugging erfarenheter i denna uppgift.

Övningen "databasklassen som en tjänst" och med att lägga upp databasmodell, för en generisk och en specialiserad för användare, var väldigt nyttig. Den generiska modellen fungerande väldigt bra för att även bygga vidare på med en specialiserad modell för kommentarer. Jag fick justera vissa metoder och omdefiniera dem. T.ex. findAll() metoden gjorde bara halva jobbet med att hämta ut data. Vissa data behövde däremot räknas ut on-the-fly (gravatar-länk och since-time). Löstes genom att överlagra findAll() i CommentsInDb som ärver från CDatabaseModel och där först anropa parent:findAll för att göra grundjobbet och sedan resten resten av datat som behövde läggas till.

Formulärhantering med CForm var betydligt smidigare än att manuellt lägga upp html-formulär och sedan försöka fånga det submittade datat. Jag satte saveInSession till false då jag annars fick gammalt ifyllt formulär-data i nytt formulär. Aktivering och soft-radering löste jag med 4 olika routes i UsersController. Ett annat kanske bättre alternativ hade varit att lägga till två radio-knapps-element för detta i update-formuläret. Hade blivit lite mindre kod och mer överskådligt för användaren. De flesta länkar i listan över users hade då försvunnit.

Modellen för kommentarer, CommentsInDb, kunde ärva basmodellen CDatabaseModel, med tillägg av init-funktion för population av test-data, sökfunktion findFlow() för att hitta kommentarer för visst flöde, hjälpfunktioner för gravatars och since-time, samt överlagring av metoden findAll(). Varje kommentar är kopplad till ett kommentarsflöde (flow) som är samma sak som route för den sidan som kommentaren skapades på. Routen skickas med som parameter för respektive action som behöver veta flow, t.ex. (webroot)/comment/add/commentadmin/lorem. Route till sidan som användaren vill kommentera blir då commentadmin/lorem. Denna route skapar två argument till funktionen "add" i controllern "comment". Argumenten klistras återigen ihop i funktionen add() mha implode() till route/flow. Route/flow sparas ihop med kommentar för att tagga kommentaren samt används efter sparning till databas för att göra redirect tillbaks till sidan där kommentaren lämnades. Det blev också väldigt smidigt att lägga till kommentars-kontrollern som en vy på en sida/route som innehåller både visning av kommentarer och länk för att skriva ny kommentar.

Viss rudimentär felhantering är inlagd i Comments- och UsersController, t.ex. om en viss kommentars-id eller users-id finns vid redigering av post, eller kontroll om användaren vill redigera acronym och spara tillbaks post med acronym som redan finns definierad för annan användare.

Användare administreras från [Användare](users). Kommentarer  administreras från [Kommentarer](commentadmin) där alla kommentarer kan visas oavset flow/route. Kommentarer finns demonstrerade på sidorna [Kalender](calendar) och [commentadmin/lorem](commentadmin/lorem).

Jag har inte gjort några av extrauppgifterna.

## Kmom03

Jag har inte arbetat med några CSS-ramverk tidigare, så det var ett väldigt nyttigt kursmoment. Det var ett ganska omfattande material att läsa in med mycket nya begrepp. LESS kändes väldigt enkelt att komma igång med. Det löser många problem jag känt vid arbete med CSS, t.ex. att kunna definiera variabler för att enkelt ändra en färg som används på flera ställen, mixins för att enkelt kunna återanvända definitioner. lessphp var ett smidigt sätt för att komma igång med LESS. En nackdel är att firebug inte direkt visar definitionerna från less-filerna utan man får försöka tolka vilken LESS-konstruktion som skapat vilken css-konstruktion. Skriver man fel LESS-syntax är det inte heller helt lätt att förstå vad som är fel var nånstans. När jag skapade filen variables.less glömde jag ta bort motsvarande definition av @total-width i grid.less. Det tog en del tid att förstå varför när jag inte fick fluid layout att fungera.

Semantic.gs var enkelt att få igång för att få till en robust layout och enkelt att få den responsiv. När jag ville styla mina olika sektioner i layout genom att lägga till borders och padding fick jag lite problem. Sektionen tog då större bredd och puttade ner sektioner som skulle ligga till höger. För att lösa det skapade jag en ".cont"-div inuti varje layout-sektion. Denna ".cont"-div kunde jag då styla och ändå få rätt bredd på omslutande sektion.

Font Awesome kikade jag lite på i förra uppgiften kmom02. Enkelt sätt att få in många olika grafiska ikoner på ett enkelt sätt. Något jag funderade på är hur accessibility, "a11y", påverkas. Jag löste det i kmom02 genom att lägga till text för ikonen med en klass .screen-reader-text som döljer texten. Normalize verkar vara en bra metod få till ett känt utgångsläge för att börja styla ett tema. Bootstrap har jag inte tittat så djupt in i. Det verkar innehålla mycket användbart alltifrån "grid system" till stylade html-element som rubriker, formulär och knappar.

Jag har gett några sidor olika utseende baserat på route. I body-elementet lägger jag till ett id döpt efter route och använder detta i min less-fil för styling av individuella sidor. På [about-](about) och [redovisnings-sidan](redovisning) har sneglat lite på koncept  från ["Google material design"](https://www.google.com/design/spec/material-design/introduction.html) där varje sektion i grid-systemet blir ett ark som ligger upphöjt ovanför bottenplanet. På sidan "regioner/typography" har jag tittat på webbplatsen [New York Times](http://www.nytimes.com/) där sektioner i rutnätet avdelas med en tunn linje. För att få fram bild över rutsystemet går det att lägga till query-variabel [?show-grid=1](?show-grid=1) efter varje route. Då jag valt att ha en border och padding på innehåll så hamnar inte rad-start på grid-systemet utan 22+1 pixlar in från kolumn-start.

Det blir många valideringsfel från font-awesome och från lessphp's genererade css-fil. Enligt "Font awesom" beror det på medvetna browser-hacks för att kunna stödja gamla browser-versioner. Även less.inc.php genererade många lint-varningar som jag stängde av med direktivet @codingStandardsIgnoreStart. I övrigt bör html och less/css validera OK.

Denna gång gav jag mig inte på någon av extrauppgifterna. Huvuduppgiften gav en tillräcklig utmaning.

## Kmom02

Den här uppgiften kändes väldigt svår i början men det lossnade allteftersom pusselbitarna föll på plats och jag fick lite bättre översikt på ramverket. Första stora problemet var att förstå hur redirect efter sparande av kommentar skulle fungera och hur värden för redirect-sidan överfördes mellan de olika komponenterna. Spara-kommentar-formuläret postar ett gömt fält som skall innehålla redirect-sidan. Denna hämtas mha getPost i controller-sidan som då kan göra redirect efter att kommentaren sparats. Till att börja med hämtade jag redirect-sidan med getCurrentUrl() i form.tpl.php men flyttade sedan ut det till front-controller index.php och skickar istället in redirect-sidan via variabel för att hålla borta php-kod från template-sidorna.

Nästa större svårighet var att förstå hur dispatcher i förhållande till view skulle fungera. Med en dispatcher kan man flytta ut mer kontroll-logik från front-controller till i detta fall CommentController. Denna CommentController skapar och lägger till en vy i den route den blivit dispatchad från istället för att skapa vyn i front-controller. Vyn skapas med hjälp av modellen som ligger i CommentsInSession.

Jag har lagt ett kommentarsflöde under sidan [Kalender](calendar) och ett annat flöde under sidan [Kommentera](comment-2). Jag har valt att använda ikoner från Font Awesome för kommentars-funktionerna redigera och radera samt för webplats- och mail-adress. Validotorn hos Unicorn gillar dock inte deras css. Enligt [Font Awesome](https://fortawesome.github.io/Font-Awesome/get-started/) så innehåller de ett antal CSS browser hacks för att fungera med gamla browser-versioner som inte validatorn gillar. Hoppas det därför är OK med dessa validator-fel.

Det fungerade smidigt att arbeta med composer efter att jag fått det installerat. Jag fick inte igång det när jag hämtade hem det via php utan installerade det via en windows-installer.

Då jag behövde lägga till funktionalitet i de två Comment-klasserna under vendor, valde jag att skapa subklasser till dessa som jag lade under app/src/Comment. Jag håller då isär mina ändringar från ursprungsklasserna och kan uppdatera via Composer för eventuella bugg-rättningar. Mina sub-klasser har samma namn som bas-klasserna så här fick jag chans att lära mig mer om namespace för att hålla isär dem.

Jag browsade runt på Packagist webbplats och hittade en hel del paket som skulle kunna vara intressanta, t.ex. modul för markdown, modul för mail-service, google api-client, blogg för phalcon, rss-feeds, etc. Den stora tröskeln för att använda en modul är nog svårigheten att veta hur mycket arbete det är att integrera en modul, samt kvaliteten på modulen. Antalet nedladdningar och stjärnmärkningar kan kanske kan ge lite vägledning om kvalitet och användbarheten.

Den uppenbara förbättringen var att lägga till stöd för olika kommentars-flöden. Här valde jag att använda mig av kommentars-sidans route som tag för flödet. Denna tag lagras i varje kommentar. Till att börja med lade jag tag-filtreringen i template-filen men fick sedan flyttat filtreringen till CommentsInSession.php. Verkade vettigt då det mer hänger ihop med modelleringen av kommentarer och flödet. Även funktioner för att uppdatera och radera kommentarer har lagts till.

En egen liten förbättringen var att lägga till funktion för att omvandla unix tidsstämpel till en relativ tid, typ "postad för 3 minueter sedan." Hittade en funktion för detta på StackExhange som passade in bra. Då tiden är relativ måste den genereras varje gång en kommentar hämtas från CommentsInSession.

För extrauppgiften att dölja kommentarsformuläret och få fram det genom att klicka på en länk så började jag  att försöka lösa det mha två olika routes: en route som **utan** vyn med kommentarsformuläret samt en route **med** vyn för kommentarsformuläret. Enkel lösning men kändes lite klumpigt att upprepa två nästan identiska routes. Istället använde jag mig av en query-variabel i url'en för att visa formuläret. Är variabeln 'showform' satt så visas formuläret. Annars döljs formuläret mha css display:none. En ännu smidigare och enklare lösning vore att använda js/jquery med .show()/.hide()/.toggle() på något sätt. Men det kommer nog i nästa kurs.

Att lägga till gravatarer gick smidigt. I modellen för kommentarer, CommentsInSession/findAll(), beräknas gravatar-url och läggs till i array för kommentar. Url'en kan sedan läsas ut i vyn för kommentarer i comments.tpl.php.

## Kmom01

Min utvecklingsmiljö består av Windows 10 eller 7 med xampp, cygwin och atom texteditor. Under oophp-kursen började jag använda git och github som jag börjar få lite grepp om, så detta hade jag tänkt fortsätta med. Repona lägger jag på dropbox med mjuka länkar från webbservern. Jag skall också försöka få igång lintning i min lokala miljö. Windows 10 är nytt för mig sedan någon vecka tillbaks men verkar fungera OK än så länge.  

Jag har inte arbetat med några ramverk tidigare. Om man möjligen räknar WordPress som ett ramverk så har jag viss erfarenhet av att göra små förändringar i funktion och utseende. Där har jag skapat några enkla plugins för att bygga ut funktionalitet samt skapat "child themes" för att ändra utseende på ett grund-tema.

Jag är inte direkt bekant med de olika begreppen runt ramverk, mönster och arkitektur mer än möjligen att jag hört namen. MVC t.ex. är ju ett välkänt namn, så det ska bli kul att se hur det kan användas.

Under denna uppgift har jag lagt in 3 relativt enkla sidor, "Om mig", "Rapport", och "Source", samt 2 extra sidor: "Kasta tärning" och "Kalender". När jag väl förstått vilka delar som behöver uppdateras var nånstans, så har arbetet för att göra själva sidorna gått snabbt och varit rättframt. Det är relativt enkelt att använda de olika tjänsterna i ramverket såsom lägga till stylesheets, skapa "snygga" länkar, filtrera markdown-text till html etc. Strukturen i ramverket uppmuntrar till bättre uppdelning av koden. T.ex. tog jag min kalender-funktion från oophp och anpassade till Anax-MVC. Det första jag fick göra var att dra ur modellen av kalendern och lägga den i app/src/CCalender, samt presentationen/vyn och lägga den i app/view/calender. För att kunna skicka rätt data till app/view/calender, anropar controllern index.php metoderna i CCalender och skickar vidare datat till kalender-vyn via ramverket. Detta känns bra, enkelt och snyggt.

Det verkar lite avigt att filerna för en app ligger utspridda i många olika mappar. Det hade känts smidigare om alla filer för en app/sida låg i en gemensam mapp. T.ex för kalendern så ligger controller-delen i weebroot/index.php, stylesheets under webroot/css, vyn ligger under app/view/calendar, modellen av kalendern ligger under app/src/Calendar samt meny-element läggs in i app/config/navbar_me.php. Det hade kännts smidigare om allt hade kunnat samlas inom en mapp som låg under mappen app/ men med en uppdelning i specifika filer t.ex. vy-, modell-, style-filer, etc.. T.ex. installation av en ny app blir enklare om den är sammanhållen med alla delar som behövs i en mapp.

Filen index.php börjar redan nu bli ganska stor och innehåller flera olika funktioner/appar. Förmodligen finns det ett sätt att ha en tunn index.php som ropar in dedicerade controller-filer efter behov.
